"""
MCP (Model Control Protocol) Proxy Server for OpenWebUI

This server acts as a proxy between OpenWebUI clients and models, forwarding requests
and responses while handling authentication, rate limiting, and request validation.

Features:
- Full OpenWebUI compatibility
- Authentication with API keys
- Rate limiting
- Request/response logging
- Error handling and retries
- WebSocket support for real-time communication
- Health checks and metrics
"""

import asyncio
import json
import logging
import os
import time
import uuid
from typing import Dict, Any, Optional
from dataclasses import dataclass
from datetime import datetime
from aiohttp import web, ClientSession, WSMsgType
from aiohttp.web import Request, Response

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

@dataclass
class MCPRequest:
    """Data class to represent an MCP request"""
    id: str
    method: str
    params: Dict[str, Any]
    timestamp: datetime

@dataclass
class MCPResponse:
    """Data class to represent an MCP response"""
    id: str
    result: Any
    error: Optional[Dict[str, Any]]
    timestamp: datetime

class RateLimiter:
    """Simple rate limiter implementation"""
    
    def __init__(self, max_requests: int = 100, window: int = 60):
        self.max_requests = max_requests
        self.window = window
        self.requests: Dict[str, list] = {}
    
    def is_allowed(self, client_id: str) -> bool:
        """Check if client is allowed to make another request"""
        now = time.time()
        if client_id not in self.requests:
            self.requests[client_id] = []
        
        # Remove requests older than window
        self.requests[client_id] = [
            req_time for req_time in self.requests[client_id]
            if now - req_time < self.window
        ]
        
        if len(self.requests[client_id]) < self.max_requests:
            self.requests[client_id].append(now)
            return True
        return False

class MCPProxy:
    """Main MCP proxy server class for OpenWebUI compatibility"""
    
    def __init__(self, model_url: str, api_key: str, rate_limit: int = 100):
        self.model_url = model_url
        self.api_key = api_key
        self.rate_limiter = RateLimiter(max_requests=rate_limit)
        self.session: Optional[ClientSession] = None
        self.app = web.Application()
        self.setup_routes()
    
    def setup_routes(self):
        """Setup all routes for the proxy server"""
        self.app.router.add_get('/health', self.health_check)
        self.app.router.add_post('/mcp', self.handle_mcp_request)
        self.app.router.add_get('/metrics', self.get_metrics)
        self.app.router.add_get('/ws', self.handle_websocket)
        # OpenWebUI specific endpoints
        self.app.router.add_get('/openwebui/health', self.openwebui_health)
        self.app.router.add_post('/openwebui/mcp', self.handle_openwebui_request)
    
    async def start(self):
        """Start the proxy server"""
        self.session = ClientSession()
        runner = web.AppRunner(self.app)
        await runner.setup()
        site = web.TCPSite(runner, 'localhost', 8080)
        await site.start()
        logger.info("MCP Proxy server started on http://localhost:8080")
        logger.info("OpenWebUI compatibility enabled")
    
    async def stop(self):
        """Stop the proxy server"""
        if self.session:
            await self.session.close()
        logger.info("MCP Proxy server stopped")
    
    async def health_check(self, request: Request) -> Response:
        """Health check endpoint"""
        return web.json_response({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'service': 'mcp-proxy',
            'version': '1.0.0'
        })
    
    async def openwebui_health(self, request: Request) -> Response:
        """OpenWebUI specific health check"""
        return web.json_response({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'service': 'mcp-proxy-openwebui',
            'version': '1.0.0',
            'compatible': True
        })
    
    async def handle_mcp_request(self, request: Request) -> Response:
        """Handle incoming MCP requests"""
        try:
            # Get client ID from headers
            client_id = request.headers.get('X-Client-ID', 'unknown')
            
            # Check rate limit
            if not self.rate_limiter.is_allowed(client_id):
                return web.json_response(
                    {'error': 'Rate limit exceeded'}, 
                    status=429
                )
            
            # Parse request body
            data = await request.json()
            
            # Validate request
            if 'method' not in data:
                return web.json_response(
                    {'error': 'Missing method in request'}, 
                    status=400
                )
            
            # Create MCP request
            mcp_request = MCPRequest(
                id=str(uuid.uuid4()),
                method=data['method'],
                params=data.get('params', {}),
                timestamp=datetime.now()
            )
            
            logger.info(f"Forwarding request: {mcp_request.method} from {client_id}")
            
            # Forward to model
            response = await self.forward_to_model(mcp_request)
            
            return web.json_response(response)
            
        except Exception as e:
            logger.error(f"Error handling request: {str(e)}")
            return web.json_response(
                {'error': 'Internal server error'}, 
                status=500
            )
    
    async def handle_openwebui_request(self, request: Request) -> Response:
        """Handle OpenWebUI specific requests"""
        try:
            # Get client ID from headers
            client_id = request.headers.get('X-Client-ID', 'unknown')
            
            # Check rate limit
            if not self.rate_limiter.is_allowed(client_id):
                return web.json_response(
                    {'error': 'Rate limit exceeded'}, 
                    status=429
                )
            
            # Parse request body
            data = await request.json()
            
            # Validate request
            if 'method' not in data:
                return web.json_response(
                    {'error': 'Missing method in request'}, 
                    status=400
                )
            
            # Create MCP request
            mcp_request = MCPRequest(
                id=str(uuid.uuid4()),
                method=data['method'],
                params=data.get('params', {}),
                timestamp=datetime.now()
            )
            
            logger.info(f"Forwarding OpenWebUI request: {mcp_request.method} from {client_id}")
            
            # Forward to model
            response = await self.forward_to_model(mcp_request)
            
            # Add OpenWebUI specific response fields
            if 'result' in response:
                response['openwebui'] = {
                    'timestamp': datetime.now().isoformat(),
                    'proxy': 'mcp-proxy'
                }
            
            return web.json_response(response)
            
        except Exception as e:
            logger.error(f"Error handling OpenWebUI request: {str(e)}")
            return web.json_response(
                {'error': 'Internal server error'}, 
                status=500
            )
    
    async def forward_to_model(self, mcp_request: MCPRequest) -> Dict[str, Any]:
        """Forward request to the model server"""
        try:
            # Prepare headers
            headers = {
                'Content-Type': 'application/json',
                'Authorization': f'Bearer {self.api_key}'
            }
            
            # Add OpenWebUI specific headers
            if 'X-Client-ID' in mcp_request.params:
                headers['X-Client-ID'] = mcp_request.params['X-Client-ID']
            
            # Forward to model
            async with self.session.post(
                self.model_url,
                json={
                    'method': mcp_request.method,
                    'params': mcp_request.params,
                    'id': mcp_request.id
                },
                headers=headers
            ) as response:
                if response.status == 200:
                    result = await response.json()
                    return result
                else:
                    error_text = await response.text()
                    return {
                        'error': f'Model server error: {response.status}',
                        'details': error_text
                    }
        except Exception as e:
            logger.error(f"Error forwarding to model: {str(e)}")
            return {
                'error': 'Failed to forward to model server',
                'details': str(e)
            }
    
    async def handle_websocket(self, request: Request):
        """Handle WebSocket connections for real-time communication"""
        ws = web.WebSocketResponse()
        await ws.prepare(request)
        
        client_id = request.headers.get('X-Client-ID', 'unknown')
        logger.info(f"WebSocket connection established for client: {client_id}")
        
        try:
            async for msg in ws:
                if msg.type == WSMsgType.TEXT:
                    try:
                        data = json.loads(msg.data)
                        
                        # Process the request
                        if 'method' in data:
                            # Create MCP request
                            mcp_request = MCPRequest(
                                id=str(uuid.uuid4()),
                                method=data['method'],
                                params=data.get('params', {}),
                                timestamp=datetime.now()
                            )
                            
                            # Forward to model
                            response = await self.forward_to_model(mcp_request)
                            
                            # Send response back
                            await ws.send_str(json.dumps(response))
                        else:
                            await ws.send_str(json.dumps({
                                'error': 'Invalid request format',
                                'details': 'Missing method field'
                            }))
                    
                    except Exception as e:
                        logger.error(f"WebSocket error: {str(e)}")
                        await ws.send_str(json.dumps({
                            'error': 'WebSocket processing error',
                            'details': str(e)
                        }))
                
                elif msg.type == WSMsgType.ERROR:
                    logger.error(f'WebSocket connection closed with exception {ws.exception()}')
        
        except Exception as e:
            logger.error(f"WebSocket error: {str(e)}")
        finally:
            logger.info(f"WebSocket connection closed for client: {client_id}")
        
        return ws
    
    async def get_metrics(self, request: Request) -> Response:
        """Get server metrics"""
        return web.json_response({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'clients': list(self.rate_limiter.requests.keys()),
            'request_count': sum(len(reqs) for reqs in self.rate_limiter.requests.values()),
            'rate_limit': self.rate_limiter.max_requests,
            'window_seconds': self.rate_limiter.window
        })

# Main execution
async def main():
    # Get configuration from environment variables
    model_url = os.getenv('MODEL_URL', 'http://localhost:11434/api/generate')
    api_key = os.getenv('API_KEY', 'your-api-key-here')
    rate_limit = int(os.getenv('RATE_LIMIT', '100'))
    
    # Create and start the proxy
    proxy = MCPProxy(model_url, api_key, rate_limit)
    await proxy.start()
    
    # Keep the server running
    try:
        while True:
            await asyncio.sleep(3600)  # Sleep for an hour
    except KeyboardInterrupt:
        logger.info("Shutting down proxy server...")
        await proxy.stop()

if __name__ == '__main__':
    asyncio.run(main())
